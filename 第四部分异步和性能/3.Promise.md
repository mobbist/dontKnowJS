# Promise
在第 2 章里，我们确定了通过回调表达程序异步和管理并发的两个主要缺陷：缺乏顺序性和可信任性。既然已经对问题有了充分的理解，那么现在是时候把注意力转向可以解决这些问题的模式了。

我们首先想要解决的是控制反转问题，其中，信任很脆弱，也很容易失去。

回忆一下，我们用回调函数来封装程序中的 continuation，然后把回调交给第三方（甚至可能是外部代码），接着期待其能够调用回调，实现正确的功能。

通过这种形式，我们要表达的意思是：“这是将来要做的事情，要在当前的步骤完成之后发生。”

但是，如果我们能够把控制反转再反转回来，会怎样呢？如果我们不把自己程序的continuation 传给第三方，而是希望第三方给我们提供了解其任务何时结束的能力，然后由我们自己的代码来决定下一步做什么，那将会怎样呢？

这种范式就称为 Promise。

随着开发者和规范撰写者绝望地清理他们的代码和设计中由回调地狱引发的疯狂行为，Promise 风暴已经开始席卷 JavaScript 世界。

实际上，绝大多数 JavaScript/DOM 平台新增的异步 API 都是基于 Promise 构建的。所以学习研究 Promise 应该是个好主意，你以为如何呢？！

本章经常会使用“立即”一词，通常用来描述某个 Promise 决议（resolution）动作。但是，基本上在所有情况下，这个“立即”指任务队列行为（参见第1 章）方面的意义，而不是指严格同步的现在。

## 　什么是 Promise
开发人员在学习新技术或新模式时，通常第一步就是“给我看看代码”。对我们来说，先跳进去学习细节是很自然的。

但是，事实证明，只了解 API 会丢失很多抽象的细节。Promise 属于这样一类工具：通过某人使用它的方式，很容易分辨他是真正理解了这门技术，还是仅仅学习和使用 API而已。

所以，在展示 Promise 代码之前，我想先从概念上完整地解释 Promise 到底是什么。希望这能够更好地指导你今后将 Promise 理论集成到自己的异步流中。

### 未来值
每次点芝士汉堡，我都知道最终要么得到一个芝士汉堡，要么得到一个汉堡包售罄的坏消息，那我就得找点别的当午饭了。

>在代码中，事情并非这么简单。这是因为，用类比的方式来说就是，订单号可能永远不会被叫到。在这种情况下，我们就永远处于一种未决议状态。后面会讨论如何处理这种情况。

1. 现在值与将来值
但在具体解释 Promise 的工作方式之前，先来推导通过我们已经理解的方式——回调——如何处理未来值。

当编写代码要得到某个值的时候，比如通过数学计算，不管你有没有意识到，你都已经对这个值做出了一些非常基本的假设，那就是，它已经是一个具体的现在值：
```
var x, y = 2;
console.log( x + y ); // NaN <-- 因为x还没有设定
```

运算 x + y 假定了 x 和 y 都已经设定。用术语简单地解释就是，这里我们假定 x 和 y 的值都是已决议的。

期望运算符 + 本身能够神奇地检测并等待 x 和 y 都决议好（也就是准备好）再进行运算是没有意义的。如果有的语句现在完成，而有的语句将来完成，那就会在程序里引起混乱，对不对？

设想如果可以通过一种方式表达：“把 x 和 y 加起来，但如果它们中的任何一个还没有准备好，就等待两者都准备好。一旦可以就马上执行加运算。”
```
function add(getX,getY,cb) {
    var x, y;
    getX( function(xVal){
        x = xVal;
        // 两个都准备好了？
        if (y != undefined) {
        cb( x + y ); // 发送和
        }
        } );
        getY( function(yVal){
        y = yVal;
        // 两个都准备好了？
        if (x != undefined) {
        cb( x + y ); // 发送和
        }
    } );
}
// fetchX() 和fetchY()是同步或者异步函数
add( fetchX, fetchY, function(sum){
 console.log( sum ); // 是不是很容易？
} ); 
```
先暂停片刻，认真思考一下这段代码的优美度（或缺少优美度，别急着喝彩）。

尽管其中的丑陋不可否认，但这种异步模式体现出了一些非常重要的东西

在这段代码中，我们把 x 和 y 当作未来值，并且表达了一个运算 add(..)。这个运算（从外部看）不在意 x 和 y 现在是否都已经可用。换句话说，它把现在和将来归一化了，因此我们可以确保这个 add(..) 运算的输出是可预测的。

通过使用这个时间上一致的 add(..)——从现在到将来的时间，它的行为都是一致的——大大简化了对这段异步代码的追踪。

当然，这个粗糙的基于回调的方法还有很多不足。要体会追踪未来值的益处而不需要考虑其在时间方面是否可用，这只是很小的第一步。

2. Promise 值
本章后面一定会深入介绍很多 Promise 的细节，因此这里如果读起来有些困惑的话，不必担心。我们先来大致看一下如何通过 Promise 函数表达这个 x + y 的例子：
```
function add(xPromise,yPromise) {
    // Promise.all([ .. ])接受一个promise数组并返回一个新的promise，
    // 这个新promise等待数组中的所有promise完成
    return Promise.all( [xPromise, yPromise] )
    // 这个promise决议之后，我们取得收到的X和Y值并加在一起
    .then( function(values){
    // values是来自于之前决议的promisei的消息数组
    return values[0] + values[1];
    } );
}
// fetchX()和fetchY()返回相应值的promise，可能已经就绪，
// 也可能以后就绪
add( fetchX(), fetchY() )
// 我们得到一个这两个数组的和的promise
// 现在链式调用 then(..)来等待返回promise的决议
.then( function(sum){
 console.log( sum ); // 这更简单！
} ); 
```

这段代码中有两层 Promise。

fetchX() 和 fetchY() 是直接调用的，它们的返回值（promise ！）被传给 add(..)。这些promise 代表的底层值的可用时间可能是现在或将来，但不管怎样，promise 归一保证了行为的一致性。我们可以按照不依赖于时间的方式追踪值 X 和 Y。它们是未来值。

第二层是 add(..)（通过 Promise.all([ .. ])）创建并返回的 promise。我们通过调用then(..) 等待这个 promise。add(..) 运算完成后，未来值 sum 就准备好了，可以打印出来。我们把等待未来值 X 和 Y 的逻辑隐藏在了 add(..) 内部。

就像芝士汉堡订单一样，Promise 的决议结果可能是拒绝而不是完成。拒绝值和完成的 Promise 不一样：完成值总是编程给出的，而拒绝值，通常称为拒绝原因（rejectionreason），可能是程序逻辑直接设置的，也可能是从运行异常隐式得出的值。

通过 Promise，调用 then(..) 实际上可以接受两个函数，第一个用于完成情况（如前所示），第二个用于拒绝情况：
```
add( fetchX(), fetchY() )
.then(
    // 完成处理函数
    function(sum) {
    console.log( sum );
    },
    // 拒绝处理函数
    function(err) {
    console.error( err ); // 烦！
    }
); 
```
如果在获取 X 或 Y 的过程中出错，或者在加法过程中出错，add(..) 返回的就是一个被拒绝的 promise，传给 then(..) 的第二个错误处理回调就会从这个 promise 中得到拒绝值。

从外部看，由于 Promise 封装了依赖于时间的状态——等待底层值的完成或拒绝，所以Promise 本身是与时间无关的。因此，Promise 可以按照可预测的方式组成（组合），而不用关心时序或底层的结果。

另外，一旦 Promise 决议，它就永远保持在这个状态。此时它就成为了不变值（immutablevalue），可以根据需求多次查看。

Promise 决议后就是外部不可变的值，我们可以安全地把这个值传递给第三方，并确信它不会被有意无意地修改。特别是对于多方查看同一个 Promise决议的情况，尤其如此。一方不可能影响另一方对 Promise 决议的观察结果。不可变性听起来似乎一个学术话题，但实际上这是 Promise 设计中最基础和最重要的因素，我们不应该随意忽略这一点

这是关于 Promise 需要理解的最强大也最重要的一个概念。经过大量的工作，你本可以通过丑陋的回调组合专门创建出类似的效果，但这真的不是一个有效的策略，特别是你不得不一次又一次重复操作。

Promise 是一种封装和组合未来值的易于复用的机制。

### 完成事件

如前所述，单独的 Promise 展示了未来值的特性。但是，也可以从另外一个角度看待Promise 的决议：一种在异步任务中作为两个或更多步骤的流程控制机制，时序上的 thisthen-that。

假定要调用一个函数 foo(..) 执行某个任务。我们不知道也不关心它的任何细节。这个函数可能立即完成任务，也可能需要一段时间才能完成。

我们只需要知道 foo(..) 什么时候结束，这样就可以进行下一个任务。换句话说，我们想要通过某种方式在 foo(..) 完成的时候得到通知，以便可以继续下一步。

在典型的 JavaScript 风格中，如果需要侦听某个通知，你可能就会想到事件。因此，可以把对通知的需求重新组织为对 foo(..) 发出的一个完成事件（completion event，或continuation 事件）的侦听。

是叫完成事件还是叫 continuation 事件，取决于你的视角。你是更关注foo(..) 发生了什么，还是更关注 foo(..) 之后发生了什么？两种视角都是合理有用的。事件通知告诉我们 foo(..) 已经完成，也告诉我们现在可以继续进行下一步。确实，传递过去的回调将在事件通知发生时被调用，这个回调本身之前就是我们之前所说的 continuation。完成事件关注 foo(..) 更多一些，这也是目前主要的关注点，所以在后面的内容中，我们将其称为完成事件。

使用回调的话，通知就是任务（foo(..)）调用的回调。而使用 Promise 的话，我们把这个关系反转了过来，侦听来自 foo(..) 的事件，然后在得到通知的时候，根据情况继续。

首先，考虑以下伪代码：

```
foo(x) {
    // 开始做点可能耗时的工作
}
foo( 42 )

on (foo "completion") {
    // 可以进行下一步了！
}
on (foo "error") {
    // 啊，foo(..)中出错了
}
```
