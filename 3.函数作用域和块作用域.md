# 函数作用域和块作用域
> 作用域包含了一系列的“气泡”，每一个都可以作为容
器，其中包含了标识符（变量、函数）的定义。这些气泡互相嵌套并且整齐地排列成蜂窝
型，排列的结构是在写代码时定义的。

## 函数中的作用域
JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡,而其他结构都不会创建作用域气泡。但事实上这并不完全正确，
```
    function foo(a) {
        var b = 2;
        // 一些代码
        function bar() {
            // ...
        }
        // 更多的代码
        var c = 3;
    }
```
在这个代码片段中，foo(..) 的作用域气泡中包含了标识符 a、b、c 和 bar。无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡。将在下一章讨论具体的原理。

由于标识符 a、b、c 和 bar 都附属于 foo(..) 的作用域气泡，因此无法从 foo(..) 的外部
对它们进行访问。也就是说，这些标识符全都无法从全局作用域中进行访问，因此下面的
代码会导致 ReferenceError 错误：
```
    bar(); // 失败
    console.log( a, b, c ); // 三个全都失败
```

但是，这些标识符（a、b、c、foo 和 bar）在 foo(..) 的内部都是可以被访问的，同样在
bar(..) 内部也可以被访问（假设 bar(..) 内部没有同名的标识符声明）。

## 隐藏内部实现
>对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来
一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际
上就是把这些代码“隐藏”起来了。

实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任
何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的
作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域
来“隐藏”它们。

为什么“隐藏”变量和函数是一个有用的技术？
>在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。

```
    function doSomething(a) {
        b = a + doSomethingElse( a * 2 );
        console.log( b * 3 );
    }
    function doSomethingElse(a) {
        return a - 1;
    }
    var b;
    doSomething( 2 ); // 15
```

在这个代码片段中，变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..) 内部具体
实现的“私有”内容。给予外部作用域对 b 和 doSomethingElse(..) 的“访问权限”不仅
没有必要，而且可能是“危险”的，因为它们可能被有意或无意地以非预期的方式使用，
从而导致超出了 doSomething(..) 的适用条件。更“合理”的设计会将这些私有的具体内
容隐藏在 doSomething(..) 内部，例如：
```
    function doSomething(a) {
        function doSomethingElse(a) {
        return a - 1;
        }
        var b;
        b = a + doSomethingElse( a * 2 );
        console.log( b * 3 );
    }
    doSomething( 2 ); // 15
```

现在，b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。
功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会
依此进行实现。

### 规避冲突

>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。
```
    function foo() {
        function bar(a) {
            i = 3; // 修改 for 循环所属作用域中的 i
            console.log( a + i );
        }
        for (var i=0; i<10; i++) {
            bar( i * 2 ); // 糟糕，无限循环了！
        }
    }
    foo();
```

bar(..) 内部的赋值表达式 i = 3 意外地覆盖了声明在 foo(..) 内部 for 循环中的 i。在这
个例子中将会导致无限循环，因为 i 被固定设置为 3，永远满足小于 10 这个条件。<br />
bar(..) 内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以，var i = 3;
就可以满足这个需求（同时会为 i 声明一个前面提到过的“遮蔽变量”）。另外一种方法是
采用一个完全不同的标识符名称，比如 var j = 3;。但是软件设计在某种情况下可能自然
而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是
唯一的最佳选择。

### 全局命名空间
>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。

```
var MyReallyCoolLibrary = {
    awesome: "stuff",
    doSomething: function() {
    // ...
    },
    doAnotherThing: function() {
    // ...
    }
};
```

### 模块管理
>第 5 章会介绍模块模式的详细内容。

## 函数作用域

