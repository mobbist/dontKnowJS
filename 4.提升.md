# 提升
>任何声明在某个作用域内的变量，都将附属于这个作用域。作用域同其中的变量声明出现的位置有某种微妙的联系.

## 先有鸡还是先有蛋
直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不完全
正确，有一种特殊情况会导致这个假设是错误的。

```
a = 2;
var a;
console.log( a );
```

会认为是 undefined，因为 var a 声明在 a = 2 之后，他们自然而然地认为变量
被重新赋值了，因此会被赋予默认值 undefined。但是，真正的输出结果是 2。
```
console.log( a );
var a = 2;
```

鉴于上一个代码片段所表现出来的某种非自上而下的行为特点，你可能会认为这个代码片
段也会有同样的行为而输出 2。还有人可能会认为，由于变量 a 在使用前没有先进行声明，
因此会抛出 ReferenceError 异常。 但其实输出来的会是 undefined。

引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来

当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明：var a; 和 a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在
原地等待执行阶段。


第一个代码片段会以如下形式进行处理：
```
var a;
a = 2;
console.log( a );
```
其中第一部分是编译，而第二部分是执行

第二个代码片段实际是按照以下流程处理

```
var a;
console.log( a );
a = 2;
```

这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了作用域的最上面。这个过程就叫作__提升__。

__先有蛋（声明）后有鸡（赋值）__。

```
foo();
function foo() {
    console.log( a ); // undefined
    var a = 2;
}
```

foo 函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可
以正常执行。 foo(..) 函数自身也会在内部对 var a 进行提升到作用域的最上面, 因此这段代码实际上会被理解为下面的形式

```
function foo() {
    var a;
    console.log( a ); // undefined
    a = 2;
}
foo();
```

可以看到，__函数声明会被提升，但是函数表达式却不会被提升__。
```
foo(); // 不是 ReferenceError, 而是 TypeError!

var foo = function bar() {
    // ...
};
```

这段程序中的变量标识符 foo() 被提升并分配给所在作用域（在这里是全局作用域），因此foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值）。foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。

```
foo(); // TypeError
bar(); // ReferenceError

var foo = function bar() {
    // ...
};
```

这个代码片段经过提升后，实际上会被理解为以下形式：
var foo;

foo(); // TypeError
bar(); // ReferenceError

foo = function() {
    var bar = ...self...
    // ...
}

##函数优先提升
>函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。
```
foo(); // 1

var foo;
function foo() {
    console.log( 1 );
}

foo = function() {
    console.log( 2 );
};
```
会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：
```
function foo() {
    console.log( 1 );
}

foo(); // 1

foo = function() {
    console.log( 2 );
};
```

var foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。

```
foo(); // 3

function foo() {
    console.log( 1 );
}

var foo = function() {
    console.log( 2 );
};

function foo() {
    console.log( 3 );
}
```

在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。

一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代
码暗示的那样可以被条件判断所控制：
```
foo(); // "b"

var a = true;
if (a) {
    function foo() { console.log("a"); }
}
else {
    function foo() { console.log("b"); }
}
```
但是需要注意这个行为并不可靠，在 JavaScript 未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数。

## 小结

我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！