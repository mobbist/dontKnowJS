# 作用域
>几乎所有的编程语言，都能够储存变量的值，并且能在之后对其进行修改或访问。 正是这种储存和访问变量的值的能力将状态带给了程序.<br>
>但是这些变量储存在哪里？ 程序需要时如何能找到它们？这些问题说明需要一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量。这套规则就叫作 __作用域__

## 编译原理
<p>尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。但与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系 统中进行移植。
</p>
<p>在传统编译语言中,程序的一段代码在执行前会经历三个步骤,统称为 编译 </p>

### 1.分词/词法分析
> 这个过程会将由字符组成的字符串分解成 (对编程语言来说) 有意义的代码块,这些代码块被称为 __词法单元__ (token)
```
    var a = 2;
```
<p>这段程序通常会被分解成为下面的语法单</p>    

```
    var , a , = , 2 , ;   
```
>空格是否会被当做测法单元, 取决于空格在这语言中是否有意义

### 2.解析/语法分析

> 这个过程是将词法单元流 (数组) 转成一个由元素逐级嵌套所组成的代表了程序语法结构的树.这个树被称为"抽象语法树"(Abstract Syntax Tree ,  AST)

### 3.代码生成

>将AST转换为可执行代码的过程被称为代码生成,这个过程与语言,平台等息息相关


--------------

<p>比起那些编译过程只有3步的语言编辑器, javascript引擎要复杂的多, 比如在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化,包括对冗余元素进行优化等</p>

<p>首先,javascript不会有大量的时间来进行优化, 因为与其他语言不同, JavaScript的编译过程不是发生在构建之前</p>

>对JavaScript来说, 大部分情况编译发生在代码执行前的几微秒(甚至更短)

__简单来说任何JavaScript代码片段在执行前都要进行编译(通常就在执行前).因此JavaScript编译器首先会对 var a = 2进行编译, 然后做好执行它的准备, 并且通常马上就会执行__

## 理解作用域
>学习作用的方式是将这个过程模拟成几个人物之间的对话

### 演员表
>首先介绍将要参与到对程序 var a=2; 进行处理的过程中的演员们,这样才能理解他们的对话

*   引擎<br />
    从头到位负责整个JavaScript程序的编译及执行过程.

*   编译器<br />
    引擎的好朋友之一,负责语法分析及代码生成等脏活累活

*   作用域<br />
    引擎的另一位好友,负责收集并维护由所有声明的标识符 (变量)组成的一系列查询,并实施一套非常严格的规则,确定当前执行的代码对这些标识符的访问权限

### 对话
> 当你看见 var a=2 这段程序时, 很可能认为这是一句声明, 但是引擎却不这么认为, 事实上,引擎认为这里有两个完全不同的声明, 一个由编译器在编译时处理,另一个则有引擎在运行时处理

<p>将var a = 2 分解,看看引擎和它的朋友们是如何协同工作的.</p>

<p>编译器首先会将这段程序分解成词法单元, 然后将词法单元解析成一个树结构. 但是当编译器开始进行代码生成时, 它对这段程序的处理方式会和预期有所不同</p>

#### 事实上编辑器会进行如下处理.
1.   遇到var a编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中. 如果是, 编译器会忽略该声明,继续进行编译; 否则它会要求作用域在当前作用域的集合声明一个新的变量,并命名为 a

2.  接下来编译器会为引擎生成运行时所需的代码,这些代码被用来处理 a= 2这个赋值操作.引擎运行时会首先询问作用域, 在当前作用域集合中是否存在一个叫做 a的变量. 如果是,引擎就会使用这个变量, 如果否,引擎会继续查找该变量,如果能够找到就会对它赋值.

### 编译器有话说

<p>编译器在编译过程的第二步中生成了代码, 引擎执行时,会通过查找变量a来判断它是否已声明过. 查找的过程由作用域进行协助, 但引擎执行怎么样的查找, 会影响最终的查找结果</p>

*   LHS 查询 (赋值)<br />
   在例子中, 引擎会为变量a 进行LHS查询.  L(left) 赋值操作 ,当变量出现赋值操作的左侧时, 进行LHS查询<br />
   LHS: 视图找到变量容器的本身, 从而可以对其赋值


*   RHS查询 (取值)
   另外一个查找类型叫作R (RHS) 查询, 当变量出现在右侧时进行RHS查询<br />
   RHS: 查找某个变量的值


```
    console.log(a)
```
<p>其中对a的引用是一个RHS引用, 因为这里a并没有赋予任何值,相应的需要查找并取得a的值,这样才能将值传递给console.log</p>

```
    a = 2
```
<p>这里对a的引用则是LHS引用, 因为实际上我们并不关心当前的值是什么, 只是想要为 = 2这个赋值操作找到一个目标</p>

___

理解这段代码,其中有LHS,也有RHS
```
    function foo(a){
        console.log(a);
    }
    foo(2);
```

<p>最后一行foo(...)函数的调用需要对foo进行RHS引用, 意味着去找到foo的值,并把它给我, 并且(...)意味着foo的值需要被执行, 因此它最好真的是一个函数类型的值.<br />
重要的细节: 代码中隐式的a =2 操作很可能被忽略掉, 这个操作发生在2被当做参数传递给foo(...)函数时,2会被分配给参数a, 为了给参数a(隐式地)分配至, 需要进行一次LHS查询.<br / >
最后对a进行RHS查询,并将得到的值传给console.log. console本身也需要一个RHS查询,并检查得到的值中是否有一个叫log的方法.
</p>

>可能会倾向于将函数声明 function foo(a){...} 概念化为普通的变量声明和赋值, 比如  var foo , foo = function(a){...}, 如果是这样理解的话,这个函数声明将需要进行LHS查询<br />
然而还有一个重要的差别, 编译器可以在代码生成的同时处理声明和值的定义, 比如在引擎执行代码时, 并不会有线程专门用来将一个函数值分配给 foo, 因此将函数声明理解成前面讨论的LHS查询和赋值的性质并不适合

## 作用域嵌套
> 作用域是根据名称查找变量的一套规则, 实际情况中, 通常需要顾及几个作用域<br/>
当一个块或函数嵌套在另一个块或函数中时, 就发生了作用域嵌套, 因此在当前作用域中无法找到某个变量时, 引擎就会在外层的作用域中继续查找, 直到找到该变量, 或抵达最外层的作用域(也就是全局作用域)为止.

<p>将作用域处理的过程可视化, 可以想象为一个高大的建筑. 这个建筑代表程序中的嵌套作用域链. 第一层代表当前执行的作用域, 建筑的顶层代表全局作用域<br / >
LHS和RHS查询都会在当前楼层进行查找, 如果没有找到, 就会坐电梯往上一层楼,以此类推,一旦抵达顶层,无论知否找到, 过程就将会停止.
</p>

## 异常
> 为什么区分LHS和RHS是一件重要的事?
因为在变量还没有声明(在任何作用域中无法找到该变量)的情况下, 这两种查询的行为是不一样的

```
    function foo(a){
        console.log(a+b);
        b=a
    }
    foo(2);
```
第一次对b进行RHS查询是无法找到该变量的, 也就是这是一个"未声明"的变量,因为在任何相关的作用域中无法找到它. 如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量, 引擎就会抛出  ReferenceError 异常.<br />

```
    a = 10   //LHS查询,没找到该变量,自动创建一个a并 =10
```
```
    "use strict"
    a = 10   //异常:
```
当引擎执行LHS查询时, 如果在全局作用域中也无法找到目标变量, 全局作用域会创建一个具有该名称的变量, 并将其返还给引擎, 前提是程序运行在非"严格模式"下.

> ES5中引入了"严格模式",严格模式在行为上有很多不同, 其中一个不同的行为是禁止自动或隐式的创建全局变量,因此在严格模式中LHS查询失败时, 引擎会抛出同RHS失败的ReferenceError的引用错误


